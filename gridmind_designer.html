<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GridMind - Level Designer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        :root {
            --bg: #0a0a0f;
            --panel: rgba(20, 20, 30, 0.95);
            --grid-bg: #12121a;
            --cell-empty: #1a1a25;
            --neon-cyan: #00fff2;
            --neon-magenta: #ff00ff;
            --neon-yellow: #ffff00;
            --neon-green: #00ff88;
            --neon-orange: #ff8800;
            --neon-red: #ff2266;
            --neon-blue: #0088ff;
            --neon-purple: #aa00ff;
            --neon-pink: #ff66aa;
            --success: #00ff9d;
            --warning: #ffaa00;
            --danger: #ff3366;
            --text: #ffffff;
            --text-dim: #888899;
            --wall-color: #3a3a4a;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--panel);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .panel-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--neon-cyan);
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 10px;
        }

        h1 {
            font-size: 28px;
            font-weight: 900;
            margin-bottom: 20px;
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-magenta));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            grid-column: 1 / -1;
        }

        /* Left Panel - Tools */
        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section-title {
            font-size: 11px;
            color: var(--text-dim);
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .tool-btn {
            padding: 12px 8px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            font-size: 10px;
        }

        .tool-btn:hover {
            border-color: var(--neon-cyan);
            background: rgba(0,255,242,0.1);
        }

        .tool-btn.active {
            border-color: var(--neon-cyan);
            background: rgba(0,255,242,0.2);
            box-shadow: 0 0 15px rgba(0,255,242,0.3);
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .color-btn {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            transform: scale(1.1);
        }

        .color-btn.active {
            border-color: white;
            box-shadow: 0 0 10px currentColor;
        }

        /* Center - Grid */
        .grid-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .grid-info {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .grid-info-item {
            background: rgba(255,255,255,0.05);
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 12px;
        }

        .grid-info-item span {
            color: var(--neon-cyan);
            font-weight: bold;
        }

        .main-grid {
            display: grid;
            gap: 3px;
            background: var(--grid-bg);
            padding: 10px;
            border-radius: 12px;
            border: 3px solid rgba(0,255,242,0.3);
        }

        .grid-cell {
            width: 45px;
            height: 45px;
            background: var(--cell-empty);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            position: relative;
            border: 2px solid transparent;
        }

        .grid-cell:hover {
            border-color: rgba(255,255,255,0.3);
        }

        .grid-cell.target-area {
            border: 2px dashed rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.03);
        }

        .grid-cell.wall {
            background: var(--wall-color) !important;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .grid-cell.wall::after {
            content: '‚ñ™';
            color: rgba(255,255,255,0.3);
        }

        .grid-cell .block-indicator {
            position: absolute;
            bottom: 2px;
            right: 3px;
            font-size: 10px;
            opacity: 0.9;
            text-shadow: 0 0 3px rgba(0,0,0,0.9);
        }

        /* Pattern Preview */
        .pattern-section {
            margin-top: 20px;
            width: 100%;
        }

        .pattern-preview {
            display: grid;
            gap: 3px;
            justify-content: center;
            margin-top: 10px;
        }

        .pattern-cell {
            width: 35px;
            height: 35px;
            border-radius: 4px;
        }

        /* Right Panel - Level Management */
        .level-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .level-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .level-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .level-item.active {
            border: 1px solid var(--neon-cyan);
            background: rgba(0,255,242,0.1);
        }

        .level-item-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .level-item-title {
            font-weight: bold;
            font-size: 13px;
        }

        .level-item-meta {
            font-size: 10px;
            color: var(--text-dim);
        }

        .level-item-actions {
            display: flex;
            gap: 5px;
        }

        .level-item-btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .level-item-btn.edit {
            background: var(--neon-blue);
            color: white;
        }

        .level-item-btn.delete {
            background: var(--danger);
            color: white;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--neon-cyan), var(--neon-blue));
            color: #000;
        }

        .btn-success {
            background: linear-gradient(135deg, var(--neon-green), var(--success));
            color: #000;
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--neon-orange), var(--neon-red));
            color: white;
        }

        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: var(--text);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        /* Form inputs */
        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            font-size: 11px;
            color: var(--text-dim);
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .form-input, .form-select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            color: var(--text);
            font-size: 13px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        /* Target area selector */
        .target-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .target-btn {
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            background: rgba(255,255,255,0.05);
            color: var(--text);
            cursor: pointer;
            font-size: 11px;
        }

        .target-btn:hover {
            background: rgba(255,255,255,0.1);
        }

        .target-btn.active {
            border-color: var(--neon-magenta);
            background: rgba(255,0,255,0.2);
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 25px;
            background: var(--panel);
            border-radius: 10px;
            border: 2px solid var(--success);
            color: var(--success);
            font-weight: bold;
            transform: translateX(150%);
            transition: transform 0.3s ease;
            z-index: 1000;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.error {
            border-color: var(--danger);
            color: var(--danger);
        }

        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-item {
            background: rgba(255,255,255,0.05);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--neon-cyan);
        }

        .stat-label {
            font-size: 10px;
            color: var(--text-dim);
            text-transform: uppercase;
        }

        /* Import section */
        .import-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéÆ GridMind Level Designer</h1>

        <!-- Left Panel - Tools -->
        <div class="panel">
            <div class="panel-title">üõ†Ô∏è Tools</div>
            
            <div class="tool-section">
                <div class="tool-section-title">Cell Types</div>
                <div class="tool-grid">
                    <button class="tool-btn active" data-tool="eraser">
                        <div class="tool-icon" style="background: var(--cell-empty);">‚úï</div>
                        <span>Eraser</span>
                    </button>
                    <button class="tool-btn" data-tool="wall">
                        <div class="tool-icon" style="background: var(--wall-color);">‚ñ™</div>
                        <span>Wall</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <div class="tool-section-title">Block Types</div>
                <div class="tool-grid">
                    <button class="tool-btn" data-tool="classic">
                        <div class="tool-icon" style="background: var(--neon-cyan);">‚Üí</div>
                        <span>Classic</span>
                    </button>
                    <button class="tool-btn" data-tool="reverse">
                        <div class="tool-icon" style="background: var(--neon-orange);">‚Üê</div>
                        <span>Reverse</span>
                    </button>
                    <button class="tool-btn" data-tool="static">
                        <div class="tool-icon" style="background: var(--neon-magenta);">‚óÜ</div>
                        <span>Static</span>
                    </button>
                    <button class="tool-btn" data-tool="hybrid">
                        <div class="tool-icon" style="background: var(--neon-green);">‚ü≥</div>
                        <span>Hybrid</span>
                    </button>
                    <button class="tool-btn" data-tool="reverse_hybrid">
                        <div class="tool-icon" style="background: var(--neon-purple);">‚ü≤</div>
                        <span>Rev.Hybrid</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <div class="tool-section-title">Block Color</div>
                <div class="color-grid" id="colorGrid"></div>
            </div>

            <div class="tool-section">
                <div class="tool-section-title">Target Area</div>
                <div class="form-row">
                    <div class="form-group">
                        <label class="form-label">Width</label>
                        <select class="form-select" id="targetWidth">
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Height</label>
                        <select class="form-select" id="targetHeight">
                            <option value="2">2</option>
                            <option value="3" selected>3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                        </select>
                    </div>
                </div>
                <button class="btn btn-secondary" onclick="enterTargetPlacementMode()">Place Target Area</button>
            </div>
        </div>

        <!-- Center - Grid -->
        <div class="panel grid-panel">
            <div class="panel-title">üìê Grid Editor</div>
            
            <div class="grid-info">
                <div class="grid-info-item">Walls: <span id="wallCount">0</span></div>
                <div class="grid-info-item">Blocks: <span id="blockCount">0</span></div>
                <div class="grid-info-item">Target: <span id="targetInfo">Not set</span></div>
            </div>

            <div class="main-grid" id="mainGrid"></div>

            <div class="pattern-section">
                <div class="tool-section-title">Target Pattern Preview</div>
                <div class="pattern-preview" id="patternPreview"></div>
            </div>
        </div>

        <!-- Right Panel - Level Management -->
        <div class="panel">
            <div class="panel-title">üìÅ Level Management</div>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalLevels">0</div>
                    <div class="stat-label">Levels</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="currentLevelNum">-</div>
                    <div class="stat-label">Editing</div>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Level Name</label>
                <input type="text" class="form-input" id="levelName" placeholder="Level 1">
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label">Time (sec)</label>
                    <input type="number" class="form-input" id="levelTime" value="60" min="10" max="300">
                </div>
                <div class="form-group">
                    <label class="form-label">Difficulty</label>
                    <select class="form-select" id="levelDifficulty">
                        <option value="Beginner">Beginner</option>
                        <option value="Easy">Easy</option>
                        <option value="Medium">Medium</option>
                        <option value="Hard">Hard</option>
                        <option value="Expert">Expert</option>
                        <option value="Master">Master</option>
                    </select>
                </div>
            </div>

            <button class="btn btn-success" onclick="saveLevel()">üíæ Save Level</button>
            <button class="btn btn-primary" onclick="newLevel()">‚ûï New Level</button>
            <button class="btn btn-secondary" onclick="clearGrid()">üóëÔ∏è Clear Grid</button>

            <div class="panel-title" style="margin-top: 20px;">üìã Saved Levels</div>
            <div class="level-list" id="levelList"></div>

            <button class="btn btn-success" onclick="downloadLevels()">‚¨áÔ∏è Download All Levels</button>
            
            <div class="import-section">
                <div class="tool-section-title">Import Levels</div>
                <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importLevels(event)">
                <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()">üìÇ Import JSON</button>
            </div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        const GRID_SIZE = 10;
        const COLORS = {
            1: '#00fff2', 2: '#ff00ff', 3: '#ffff00', 4: '#00ff88',
            5: '#ff8800', 6: '#ff2266', 7: '#0088ff', 8: '#aa00ff', 9: '#ff66aa'
        };

        const BLOCK_SYMBOLS = {
            classic: '‚Üí',
            reverse: '‚Üê',
            static: '‚óÜ',
            hybrid: '‚ü≥',
            reverse_hybrid: '‚ü≤'
        };

        let state = {
            currentTool: 'eraser',
            currentColor: 1,
            grid: [], // 2D array: null, 'wall', or {type, color, targetColor}
            targetPosition: null, // {x, y, width, height}
            targetPattern: [], // 2D array of target colors
            levels: [],
            editingLevelIndex: -1,
            isPlacingTarget: false
        };

        // Initialize
        function init() {
            createGrid();
            createColorPalette();
            setupToolButtons();
            loadFromLocalStorage();
            updateUI();
        }

        function createGrid() {
            const grid = document.getElementById('mainGrid');
            grid.innerHTML = '';
            grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 45px)`;

            state.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                state.grid[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    state.grid[y][x] = null;

                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    cell.addEventListener('click', () => handleCellClick(x, y));
                    cell.addEventListener('mouseenter', (e) => {
                        if (e.buttons === 1) handleCellClick(x, y);
                    });
                    grid.appendChild(cell);
                }
            }
        }

        function createColorPalette() {
            const palette = document.getElementById('colorGrid');
            palette.innerHTML = '';

            for (let i = 1; i <= 9; i++) {
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (i === 1 ? ' active' : '');
                btn.style.backgroundColor = COLORS[i];
                btn.dataset.color = i;
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentColor = i;
                });
                palette.appendChild(btn);
            }
        }

        function setupToolButtons() {
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.currentTool = btn.dataset.tool;
                    state.isPlacingTarget = false;
                });
            });
        }

        function handleCellClick(x, y) {
            if (state.isPlacingTarget) {
                placeTargetArea(x, y);
                return;
            }

            const tool = state.currentTool;

            if (tool === 'eraser') {
                state.grid[y][x] = null;
            } else if (tool === 'wall') {
                // Can't place wall in target area
                if (!isInTargetArea(x, y)) {
                    state.grid[y][x] = 'wall';
                }
            } else {
                // Block types
                state.grid[y][x] = {
                    type: tool,
                    color: state.currentColor,
                    targetColor: state.currentColor
                };
            }

            renderGrid();
            updateTargetPattern();
            updateUI();
        }

        function isInTargetArea(x, y) {
            if (!state.targetPosition) return false;
            const t = state.targetPosition;
            return x >= t.x && x < t.x + t.width && y >= t.y && y < t.y + t.height;
        }

        function enterTargetPlacementMode() {
            state.isPlacingTarget = true;
            showToast('Click on grid to place target area top-left corner');
        }

        function placeTargetArea(x, y) {
            const width = parseInt(document.getElementById('targetWidth').value);
            const height = parseInt(document.getElementById('targetHeight').value);

            // Check bounds
            if (x + width > GRID_SIZE || y + height > GRID_SIZE) {
                showToast('Target area out of bounds!', true);
                return;
            }

            state.targetPosition = { x, y, width, height };
            state.isPlacingTarget = false;

            // Clear walls in target area
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    if (state.grid[y + dy][x + dx] === 'wall') {
                        state.grid[y + dy][x + dx] = null;
                    }
                }
            }

            renderGrid();
            updateTargetPattern();
            updateUI();
            showToast('Target area placed!');
        }

        function updateTargetPattern() {
            if (!state.targetPosition) {
                state.targetPattern = [];
                return;
            }

            const t = state.targetPosition;
            state.targetPattern = [];

            for (let dy = 0; dy < t.height; dy++) {
                state.targetPattern[dy] = [];
                for (let dx = 0; dx < t.width; dx++) {
                    const cell = state.grid[t.y + dy][t.x + dx];
                    if (cell && cell !== 'wall') {
                        state.targetPattern[dy][dx] = cell.targetColor;
                    } else {
                        state.targetPattern[dy][dx] = 1; // Default color
                    }
                }
            }

            renderPatternPreview();
        }

        function renderGrid() {
            const cells = document.querySelectorAll('.grid-cell');
            
            cells.forEach(cell => {
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const data = state.grid[y][x];

                // Reset
                cell.className = 'grid-cell';
                cell.style.backgroundColor = '';
                cell.innerHTML = '';

                // Target area highlight
                if (isInTargetArea(x, y)) {
                    cell.classList.add('target-area');
                }

                if (data === 'wall') {
                    cell.classList.add('wall');
                } else if (data && typeof data === 'object') {
                    cell.style.backgroundColor = COLORS[data.color];
                    const indicator = document.createElement('span');
                    indicator.className = 'block-indicator';
                    indicator.textContent = BLOCK_SYMBOLS[data.type];
                    cell.appendChild(indicator);
                }
            });
        }

        function renderPatternPreview() {
            const preview = document.getElementById('patternPreview');
            preview.innerHTML = '';

            if (!state.targetPattern.length) {
                preview.innerHTML = '<div style="color: var(--text-dim); font-size: 12px;">Set target area first</div>';
                return;
            }

            const width = state.targetPattern[0].length;
            preview.style.gridTemplateColumns = `repeat(${width}, 35px)`;

            for (let y = 0; y < state.targetPattern.length; y++) {
                for (let x = 0; x < state.targetPattern[y].length; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'pattern-cell';
                    cell.style.backgroundColor = COLORS[state.targetPattern[y][x]];
                    
                    // Click to change target color
                    cell.addEventListener('click', () => {
                        state.targetPattern[y][x] = state.currentColor;
                        renderPatternPreview();
                    });
                    
                    preview.appendChild(cell);
                }
            }
        }

        function updateUI() {
            // Count walls and blocks
            let walls = 0, blocks = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (state.grid[y][x] === 'wall') walls++;
                    else if (state.grid[y][x]) blocks++;
                }
            }

            document.getElementById('wallCount').textContent = walls;
            document.getElementById('blockCount').textContent = blocks;
            document.getElementById('targetInfo').textContent = state.targetPosition 
                ? `${state.targetPosition.width}√ó${state.targetPosition.height} at (${state.targetPosition.x},${state.targetPosition.y})`
                : 'Not set';

            document.getElementById('totalLevels').textContent = state.levels.length;
            document.getElementById('currentLevelNum').textContent = state.editingLevelIndex >= 0 
                ? state.editingLevelIndex + 1 
                : '-';

            renderLevelList();
        }

        function renderLevelList() {
            const list = document.getElementById('levelList');
            list.innerHTML = '';

            state.levels.forEach((level, index) => {
                const item = document.createElement('div');
                item.className = 'level-item' + (index === state.editingLevelIndex ? ' active' : '');
                item.innerHTML = `
                    <div class="level-item-info">
                        <div class="level-item-title">${level.name || 'Level ' + (index + 1)}</div>
                        <div class="level-item-meta">${level.targetWidth}√ó${level.targetHeight} | ${level.time}s | ${level.difficulty}</div>
                    </div>
                    <div class="level-item-actions">
                        <button class="level-item-btn edit" onclick="loadLevel(${index})">‚úèÔ∏è</button>
                        <button class="level-item-btn delete" onclick="deleteLevel(${index})">üóëÔ∏è</button>
                    </div>
                `;
                list.appendChild(item);
            });
        }

        function saveLevel() {
            if (!state.targetPosition) {
                showToast('Please set target area first!', true);
                return;
            }

            // Collect blocks
            const blocks = [];
            const walls = [];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = state.grid[y][x];
                    if (cell === 'wall') {
                        walls.push({ x, y });
                    } else if (cell && typeof cell === 'object') {
                        blocks.push({
                            x, y,
                            type: cell.type,
                            color: cell.color,
                            targetColor: cell.targetColor,
                            targetX: state.targetPosition.x + (blocks.length % state.targetPosition.width),
                            targetY: state.targetPosition.y + Math.floor(blocks.length / state.targetPosition.width)
                        });
                    }
                }
            }

            // Validate
            const expectedBlocks = state.targetPosition.width * state.targetPosition.height;
            if (blocks.length !== expectedBlocks) {
                showToast(`Need ${expectedBlocks} blocks for target area, found ${blocks.length}`, true);
                return;
            }

            const levelData = {
                name: document.getElementById('levelName').value || 'Level ' + (state.levels.length + 1),
                time: parseInt(document.getElementById('levelTime').value) || 60,
                difficulty: document.getElementById('levelDifficulty').value,
                targetX: state.targetPosition.x,
                targetY: state.targetPosition.y,
                targetWidth: state.targetPosition.width,
                targetHeight: state.targetPosition.height,
                targetPattern: state.targetPattern,
                walls: walls,
                blocks: blocks
            };

            if (state.editingLevelIndex >= 0) {
                state.levels[state.editingLevelIndex] = levelData;
                showToast('Level updated!');
            } else {
                state.levels.push(levelData);
                state.editingLevelIndex = state.levels.length - 1;
                showToast('Level saved!');
            }

            saveToLocalStorage();
            updateUI();
        }

        function loadLevel(index) {
            const level = state.levels[index];
            state.editingLevelIndex = index;

            // Clear grid
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    state.grid[y][x] = null;
                }
            }

            // Load walls
            level.walls.forEach(w => {
                state.grid[w.y][w.x] = 'wall';
            });

            // Load blocks
            level.blocks.forEach(b => {
                state.grid[b.y][b.x] = {
                    type: b.type,
                    color: b.color,
                    targetColor: b.targetColor
                };
            });

            // Load target
            state.targetPosition = {
                x: level.targetX,
                y: level.targetY,
                width: level.targetWidth,
                height: level.targetHeight
            };
            state.targetPattern = level.targetPattern;

            // Update form
            document.getElementById('levelName').value = level.name;
            document.getElementById('levelTime').value = level.time;
            document.getElementById('levelDifficulty').value = level.difficulty;
            document.getElementById('targetWidth').value = level.targetWidth;
            document.getElementById('targetHeight').value = level.targetHeight;

            renderGrid();
            renderPatternPreview();
            updateUI();
            showToast('Level loaded!');
        }

        function deleteLevel(index) {
            if (confirm('Delete this level?')) {
                state.levels.splice(index, 1);
                if (state.editingLevelIndex === index) {
                    state.editingLevelIndex = -1;
                } else if (state.editingLevelIndex > index) {
                    state.editingLevelIndex--;
                }
                saveToLocalStorage();
                updateUI();
                showToast('Level deleted!');
            }
        }

        function newLevel() {
            state.editingLevelIndex = -1;
            clearGrid();
            document.getElementById('levelName').value = 'Level ' + (state.levels.length + 1);
            showToast('Ready for new level!');
        }

        function clearGrid() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    state.grid[y][x] = null;
                }
            }
            state.targetPosition = null;
            state.targetPattern = [];
            renderGrid();
            renderPatternPreview();
            updateUI();
        }

        function downloadLevels() {
            if (state.levels.length === 0) {
                showToast('No levels to download!', true);
                return;
            }

            const exportData = {
                version: '1.0',
                generatedAt: new Date().toISOString(),
                totalLevels: state.levels.length,
                levels: state.levels
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'gridmind_levels_' + Date.now() + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            showToast(`Downloaded ${state.levels.length} levels!`);
        }

        function importLevels(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data.levels && Array.isArray(data.levels)) {
                        const count = data.levels.length;
                        state.levels = [...state.levels, ...data.levels];
                        saveToLocalStorage();
                        updateUI();
                        showToast(`Imported ${count} levels!`);
                    } else {
                        showToast('Invalid file format!', true);
                    }
                } catch (err) {
                    showToast('Error reading file: ' + err.message, true);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        function saveToLocalStorage() {
            localStorage.setItem('gridmind_designer_levels', JSON.stringify(state.levels));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('gridmind_designer_levels');
            if (saved) {
                try {
                    state.levels = JSON.parse(saved);
                } catch (e) {
                    state.levels = [];
                }
            }
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 2500);
        }

        // Initialize on load
        init();
    </script>
</body>
</html>
